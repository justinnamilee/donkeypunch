#!/usr/bin/env bash

####################
#>donkey<3.0>punch<#
#######################
#                     #
# Author:  Justin Lee #
# Date:    2019-03-08 #
# Version: 3.0        #
# License: beerware   #
#                     #
####################################################
#                                                  #
# donkeypunch:                                     #
#                                                  #
#   This service-oriented SSH reverse relay script #
#   will keep a hole punched in any network that   #
#   does not explicitly filter your relay gateway  #
#   IP address or the port you choose to exit on.  #
#   This is useful when you need to access a       #
#   computer behind a firewall or use it like a    #
#   VPN end-point because your netadmin still      #
#   hasn't gotten around to getting you that VPN   #
#   access you need!                               #
#                                                  #
####################################################


sleep 1


##
# the best kind of trap

trap service_stop SIGTERM

##
# exit codes

_SERVICE_STOP=0    # good & stop
_SERVICE_FAIL=1    # bad & stop
_SERVICE_RESTART=7 # bad & restart


##
# logging to syslog incase run stand alone

_LOG="$(which logger) --id=$$ --tag $(basename $0) -p daemon.info" 

$_LOG "Never forget to punch that donkey!"


##
# look for our source file

if [ -r $_ENV ]; then

	$_LOG "Loading environment file [$_ENV]."

	# load that source file, yo
	source $_ENV
else

	$_LOG "Unable to load environment file [$_ENV]."

	# don't try to restart the service
	exit $_SERVICE_FAIL;
fi


##
# script config vars

_DEL=5                    # Delay between process checks.
_TRK=500                  # Display a poll every 500 naps (based on $_DEL)
_SCR=$(basename $0)       # Get running script name.
_LCK="$_SCR-$_NAM"        # Generate name for lock & count files.
_CNT="/var/run/$_LCK.cnt" # Run count file, tracks connection attempts.
_PID="/var/run/$_LCK.pid" # Run PID lock file.
_SSH="$(which ssh) $_OPT" # SSH command.
_DBG=                     # Set to 1 for debugging, clear for none.


##
# functions

function set_pid
{
	# save pid lock file
	echo $1 > $_PID
}

function get_pid
{
	# get PID from lock file
	cat $_PID 2>/dev/null
}

function chk_pid
{
	CHECK=$(get_pid)

	# is the process alive and well?
	[ $CHECK ] && kill -0 $CHECK > /dev/null 2>&1
}

function upt_pid
{
	# get the uptime for the PID
	ps --no-headers -o etime -p $(get_pid) 2>/dev/null | sed -E 's/\s+//g'
}

function get_name
{
	"$_NAM@$_GWA"
}

function set_count
{
	# set the count file
	echo $1 > $_CNT
}

function get_count
{
	# get the current count from the count file
	cat $_CNT 2>/dev/null
}


##
# misc functions

function has_rw
{
	[ -r $1 ] && [ -w $1 ]
}

function dne_or_has_rw
{
	[ ! -e $1 ] || has_rw $1
}

function debug
{
	if [ $_DBG ]; then

		$_LOG "<DEBUG> $1"
	fi
}


##
# trapped SIGTERM does clean up on service stop

function service_stop
{
	# shit to do before we stop the service
	rm $_PID > /dev/null 2>&1
	rm $_CNT > /dev/null 2>&1

	# call exit when done with our stop code
	exit $_SERVICE_STOP
}


## 
# start up checks!

# check for read/write on our lock files
if dne_or_has_rw $_CNT && dne_or_has_rw $_PID; then

	# just some basic checks... you know
	if [ -z $(which ssh) ]; then

		$_LOG "You'll be needing SSH, bud."

		# don't try to restart
		exit $_SERVICE_FAIL
	fi
else

	$_LOG "Someone else has our lock files, cannot proceed."

	# don't try to restart
	exit $_SERVICE_FAIL
fi


##
# check for "startup mode" / new instance

if [ ! -e $_PID ]; then

	set_count 1

	$_LOG "Initializing first connection to relay [$(get_name)]."
else

	if chk_pid; then

		# the connection is still up? nothing to do
		$_LOG "Connection [$(get_name)] still alive at [$(get_pid)]."

		# do not try to restart this service instance
		exit $_SERVICE_STOP
	else

		# connection no longer running, time to fire it up again
		COUNT=$(get_count)
		COUNT=$((COUNT+1))

		# save updated connection count
		set_count $COUNT

		$_LOG "Reconnecting to relay [$(get_name)]: $COUNT connections this session."
	fi
fi


##
# punch that donkey and save the PID

$_SSH -i $_SID -R $_GWF:$_FWA:$_FWP -p $_GWP $_USR@$_GWA &

# save pid and have a nap
set_pid $!
sleep $_DEL

# some debug info
debug "COMMAND: $_SSH -i $_SID -R $_GWF:$_FWA:$_FWP -p $_GWP $_USR@$_GWA &"
debug "PID: $(get_pid)"
debug "UPTIME: $(upt_pid)"


##
# track and check connection status

if chk_pid; then

	$_LOG "Forked relay [$(get_name)] to background [$(get_pid)]."

	TRACK=0

	# poll forever on SSH PID
	while chk_pid; do

		# it's still alive so have a nap
		sleep $_DEL

		# update tracker info
		TRACK=$((TRACK+1))
		POLL="POLL: Relay alive [$(get_name)] for [$(upt_pid)] at [$(get_pid)]."

		# check if we need to log it or debug log it
		if [ $TRACK -ge $_TRK ]; then

			# reset counter
			TRACK=0

			# log poll
			$_LOG "$POLL"
		else

			# defaults to debug log every $_DEL seconds
			debug "$POLL"
		fi
	done

	# ssh connection failed
	# break out of poll loop
	$_LOG "Relay [$_NAM:$_GWA] no longer running...restarting."
else

	# initial ssh connection failed
	$_LOG "Relay [$_NAM:$_GWA] failed to start...restarting."
fi


##
# relay died or failed to start, try again

exit $_SERVICE_RESTART
